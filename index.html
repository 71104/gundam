<!DOCTYPE html>
<html>
<head>
	<title>Sonic The Hedgehog</title>
	<link rel="stylesheet" type="text/css" href="css/style.css"/>
	<script type="text/javascript" src="js/oogl-1.0.0.js"></script>
	<script type="text/javascript" src="js/QueryableDocument.js"></script>
</head>
<body>
	<canvas id="canvas">
		<p>No browser support, sorry.</p>
	</canvas>
	<script type="text/javascript">
window.requestAnimationFrame = window.requestAnimationFrame ||
	window.mozRequestAnimationFrame ||
	window.webkitRequestAnimationFrame ||
	window.oRequestAnimationFrame;

function Mesh(oogl, arrays) {
	this.draw = function () {
		arrays.bindAndPointer();
		arrays.drawTriangles();
	};
}

function loadMesh(document, node, oogl) {
	function loadFloatArray(xpath) {
		return document.queryString(node, xpath).replace(/^\s+/, '').replace(/\s+$/, '').split(/\s+/).map(parseFloat);
	}

	function loadIntArray(xpath) {
		return document.queryString(node, xpath).replace(/^\s+/, '').replace(/\s+$/, '').split(/\s+/).map(function (string) {
			return parseInt(string, 10);
		});
	}

	var positions = loadFloatArray(
'./source[\
	concat(\"#\", @id) = ../vertices/input[\
		@semantic = \"POSITION\"\
	]/@source\
]/float_array[\
	concat(\"#\", @id) = ../technique_common/accessor[\
		@stride = \"3\"\
	]/@source\
]'
		);
	var textureCoordinates = loadFloatArray(
'./source[\
	concat(\"#\", @id) = ../polylist/input[\
		@semantic = \"TEXCOORD\"\
	]/@source\
]/float_array[\
	concat(\"#\", @id) = ../technique_common/accessor[\
		@stride = \"2\"\
	]/@source\
]'
		);

	var arrays = (function () {
		var counts = loadIntArray('./polylist/vcount');
		var indices = loadIntArray('./polylist/p');

		var stride = document.queryNumber(node, 'count(./polylist/input)');
		var positionOffset = parseInt(document.queryString(node,
'./polylist/input[\
	@semantic = \"VERTEX\"\
]/@offset'
			), 10);
		var textureCoordinateOffset = parseInt(document.queryString(node,
'./polylist/input[\
	@semantic = \"TEXCOORD\"\
]/@offset'
			), 10);

		var finalPositions = [];
		var finalTextureCoordinates = [];

		function pushVertex(i) {
			finalPositions.push(positions[indices[i + positionOffset] * 3]);
			finalPositions.push(positions[indices[i + positionOffset] * 3 + 1]);
			finalPositions.push(positions[indices[i + positionOffset] * 3 + 2]);
			finalTextureCoordinates.push(textureCoordinates[indices[i + textureCoordinateOffset] * 2]);
			finalTextureCoordinates.push(textureCoordinates[indices[i + textureCoordinateOffset] * 2 + 1]);
		}

		var i = 0;
		counts.forEach(function (count) {
			switch (count) {
			case 3:
				pushVertex(i);
				pushVertex(i + stride);
				pushVertex(i + stride * 2);
				break;
			case 4:
				pushVertex(i);
				pushVertex(i + stride);
				pushVertex(i + stride * 2);
				pushVertex(i + stride * 2);
				pushVertex(i + stride * 3);
				pushVertex(i);
				break;
			}
			i += stride * count;
		});

		var arrays = new oogl.AttributeArrays(finalPositions.length / 3);
		arrays.add3f(finalPositions);
		arrays.add2f(finalTextureCoordinates);
		arrays.enable();
		return arrays;
	})();

	return new Mesh(oogl, arrays);
}

OOGL(function () {
	var canvas = document.getElementById('canvas');
	canvas.width = window.innerWidth;
	canvas.height = window.innerHeight;

	canvas.addEventListener('contextmenu', function (event) {
		event.preventDefault();
	}, false);

	var oogl = new OOGL.Context(canvas, {
		alpha: false
	});
	oogl.enable(oogl.DEPTH_TEST);

	OOGL.Ajax.get('media/dae/gundam.dae', function (response) {
		var document = new QueryableDocument(response);
		var meshes = [];
		document.forEachNode('/COLLADA/library_geometries/geometry/mesh', function (node) {
			meshes.push(loadMesh(document, node, oogl));
		});
		var texture = new oogl.AsyncTexture('media/img/gundam.png', function () {
			var program = new oogl.AjaxProgram('glsl/gundam', ['in_Vertex', 'in_TexCoord'], function () {
				var angleX = 0;
				var angleY = 0;
				var offsetX = 0;
				var offsetY = 0;

				function render() {
					oogl.clear(oogl.COLOR_BUFFER_BIT | oogl.DEPTH_BUFFER_BIT);
					program.uniform2fv('Rotation', [angleX, angleY]);
					program.uniform2fv('Translation', [offsetX, offsetY]);
					meshes.forEach(function (mesh) {
						mesh.draw();
					});
					oogl.flush();
				}

				program.use();
				program.uniform1f('ScreenRatio', canvas.width / canvas.height);
				program.uniform1f('Zoom', 0.05);
				requestAnimationFrame(render);

				var mode = null;
				var x0, y0;
				canvas.addEventListener('mousedown', function (event) {
					event.preventDefault();
					console.log(mode = ['rotate', null, 'translate'][event.button]);
					x0 = event.clientX;
					y0 = event.clientY;
				}, false);
				canvas.addEventListener('mousemove', function (event) {
					event.preventDefault();
					switch (mode) {
					case 'rotate':
						angleX += (y0 - event.clientY) * 0.01;
						angleY += (event.clientX - x0) * 0.01;
						break;
					case 'translate':
						offsetX += (event.clientX - x0) * 0.05;
						offsetY += (y0 - event.clientY) * 0.05;
						break;
					default:
						return;
					}
					requestAnimationFrame(render);
					x0 = event.clientX;
					y0 = event.clientY;
				}, false);
				canvas.addEventListener('mouseup', function () {
					event.preventDefault();
					mode = null;
				}, false);
			});
		});
	}, 'document');
});
	</script>
</body>
</html>
